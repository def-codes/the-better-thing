# On Hashtags and other things

## Hashtags

Hashtags are identifiers.

How can you tell it's a hastag? (hasTell)

Browsers provide hyperlink-based navigation for free.

We can interpret the selection of a succession of links in any way that we want.
Browser history is kind of like `stdin`.

## Navigating as creating (prelude)

When you follow a hashtag link, the *default* behavior is to scroll to the
element bearing the hashtag as its name.

This default applies only to the already-used names of an already-existing thing
in the graph/model.

What user agents do when the anchor link does not exist, is undefined as far as
I know.  It seems to me that navigating should visibly create another context.

Once we know that a `Carol` exists, we can make statements about whoever `Carol`
may be, with no ambiguity about whom we mean.

Situated links can act as little factories.

They can suggest a path forward.

There is a straight line from this to boggle solver.

## Context drives the representation of the thing... but not the thing itself

## Assertions - Facts - Propositions - Claims

They all mean the same thing: you're telling me something is true.

But regardless of the term, note the difference with calling them "Truths."

“Assertions” beg for a challenge, and “propositions” are dubious beasts.

"Facts" approaches the presumption of authority, although I think it's fair to
say that "facts" are now officially undecidable by default.

Anyway, I tend to use the word "claims" for this class of things.  It's almost a
short as “facts” and conveys the propositional nature without scare quotes.

## Values

Cohabitating the world with "claims of truth" are things called "values".

I would say that values have “no strings attached,” but I would rather make a
positive assertion, as I don't believe that the value of values depends on
negation.

I would say that a value is "of no consequence", since they do not themselves
trigger any kind of dispatch (indeed, they have no strings attached).

Representations of values can be navigable, by containing links to other things.
Values can thus serve indirectly as (the locus of) inflection points in a
sequence (of navigation).

## Identifiable - Identity

Resources are Identifiable.  Indeed, we cannot talk about a resource without
first identifying it.

Values are not Identifiable, though they are Comparable.

Identify is seen as in Clojure: a succession of immutable states over time.

## Comparison

All comparison is value-based comparison.

## Claims and values are mutually recursive

Claims and values are siblings, they are both children of "data."

Claims can include values, and values can refer to claims.

The difference between “claims” and “values” is that truth cannot be imputed to
values *per se*, i.e. they have no truth value.

## Claims extend values with predicates

Interpreters must recognize a value versus a claim.

How can we *tell* it's a claim?

Claims are also values, and they cannot change the semantics of what values say
is true about their subjects.

## Representations can linger long after the death of its main process

## Things-in-themslves - the inherent authority of supertypes

Semantics-driven transformations made at higher abstration layers must not
obscure the value-nature of the underlying supertypes.  How is that possible?
By constraining the algebra of trait-exhibiting transforms to a set of
conflict-free operations.  That is, a family of terms where contradiction is
impossible to state.

## Domains as challenge arbiters (i.e. authorities)

Instances almost always reside in a different domain than their types.

How much of a thing's representation can the owner of those domains claim?

You must always be able to look at things at a lower level of abstraction
(preservation of semantics of supertypes).  In which case other domains may have
stronger precedence.  There must be a way of weighting this, too.

Yet, in *your* domains (including all local, ad hoc namespaces), you must have
some precedence.

Similarities to CSS (stylesheets < inline < user agent)

## Planar forcefield arbitration scheme

Idea: 

For one or more scalar properties, let each be represented by a body in a (new?)
forcefield.

Let each of a set of resources be a body in a forcefield.

Let the interested resources assert descriptions of forces on the placement of
the bodies that they claim exert on the represented property, in any given
context.

The domains thus arbitrate not by making simultaneous claims about a specific
amount, but by way of claims about the determination of its value in any given
context, where it coexists with other such claims, and not one of them precludes
another.

## Simulation as a domain

Space
Body
Forcefield

`FrameSimulation` is `Iterable`.

`Iterable` is stateful

Let the successive states of the bodies in the space be an iterable dictionary.

Monotonicity.  Extension.

It is a function of the simulation ticker.  Simulation ticker is a functional
property, as the simulation can only have one ticker.  The simulation is
stateful.

We must interpret them as the properties of the bodies representing the things.

## Representation over reference

When representing things whose terms come from "other" namespaces, you must
refer to them in some way.

This is a bit like value over identity.  Let the thing speak for itself, let me
not take it on authority.

## Conflict prevention

Contradiction, as you probably know, has drastic consequences for the outlook of
a language.

Prevention is the best cure, as usual.

Prefer *open* semantics.  Design families of terms in a way that precludes the
possibility of contradiction.

## Conflict mitigation - Optionality over requirement

Despite our preventive efforts, some conflict is unavoidable.

Conflict is a tax we can pay to secure a greater expressive range,

Example where conflict is worth it.  Negation -- right?

Conflict has consequences.

Conflict may also be *unresolvable*, which may have consequences.

Preferring *optionality* over *requirement* mitigates the consequences of
conflict.

Goals with subgoals mired in conflict may decide that the juice is not worth the
squeeze.

If your member's goal was not a *required* input to "your" goal, you can carry
on with your claim, as far as we're concerned.

An optional goal is a body in a composition, where the composition is a pattern

How is an optional body depicted in a pattern, and a match result.  A match
result extends a pattern.


## Conflict resolution (dup)

Some operations may allow parties to impute contradictory claims.

If a conflict arises in the course of a goal, that goal remains unattainable as
long as it is blocked by an unresolvable conflict.

One consequence is that the activity being undertaken at the time of the
conflict will likely fail.

## Disjunction

A *disjunction* divides one or more classes from others.

Disjunctive statements require negative assertions.  If you want to say that
Alice and Bob are *different* people; i.e., you can't be Bob if you're Alice,
and vice versa.

## Negation in RDF

RDF lacks a first-class notion of negation.  We cannot directly say, "Alice is
not Bob".  But we can imply as much by adopting ontological terms, whose logical
consequences are formalized as _entailment regimes_.

Physical bodies are spatially *disjunctive*: they cannot occupy the same place
at the same time.

## Universality of physical properties - our need to exploit it

Negation introduces a new level of complexity.

Computational complexity has direct consequences for the capability of a thing.

What keeps them from doing that?

Yet physical bodies are *disjunctive* without making negative statements
involving each other.

They do it naturally.  It is in their nature as solid bodies.  That property
comes from a much lower abstraction layer than our typical discourse.  That is,
we don't think it a special property of a thing; it is accomplished through no
power of its own, or at least no power specially its own.  It is certainly not a
distinguishing trait of any kind of thing, a la: Cats are feline things that
can't occupy the same space as other things; Dogs... etc

The universality of physical properties must be exploited as having descriptive
power in abstracted contexts.
	 
## Rights of domain owner over representation

We will want to make claims about our things --- to make them appear in
different forms.

When other domains refer to our terms, we want some say over how they are
represented.

But if an implementation is able to verify the integrity of a resource bearing
claims about that domain's manifestations, then it must give priority to claims
coming from the domain in question, all in matters of dispute then defined.

(Note that verifying the *authenticity* of the resource content does *not*
entail verifying any claims it may entail.)

This, a term's home domain can take precedence over other claims in certain
situations.

The only precedence relationship is also a predicate
- is it in your domain or not?
- i.e. in what namespace are you claiming this?


## The further impossibility of impossibility

Even “conflict-free” composition does not create guaranteed invariants.

Even in the absence of contradiction, we cannot for example, make a rule
asserting that all things shall be visible.  We *can* say, "For all Things, that
Thing has a Representation," and find words to express the proposal that the
representation should be ever faithful.  But invisible in that claim would be
its author's ignorance of the existence of a viewport, where duly-represented
things can become occluded for reasons quite alien to the rule's upholders
(including their representatives), which of force know nothing of their outer
context.

## Polymorphism

Polymorphism is *situational response*, the sometime province of man.

We must be polymorphic to read this.  We can treat these ideas with a kind of
abandon for the "real world" that would not suit other modes of activity.  We
are able to read into the relative peace of our community, that we have a moment
to be together, to speak peacefully.

Things are polymorphic in that they are handled by other things in different
ways based on their characteristics.  And every time you discriminate one type
of thing from another, and treat them specially, you are polymorphing.

## Single dispatch has a point of view.

With spec-conformance and tagging functions, single-dispatch polymorphism can
discriminate on an open set of complex predicates with global names.

Still, the targets of polymorphic dispatch only know what they know.

In a realm of directional subject-object propositions, subjects do not "know"
all that is claimed about them in a knowledge base.

## Generalized interpreter context

What if the interpretation of a term could also consider statements in which its
target is the *object*, not the subject, of a claim.  A typical target would
have no way of knowing many of these.

Further out, we could identify traits whose essential qualities are only
"adjacent" to the subject, and those traits may be contagious.  Why would we
want contagious traits?  Because they're super interesting to play with.

The fact that we have this subject-oriented point of view is an artifact of the
dispatching model.  What is the "point of view" when anything happens?  What
kinds of things can happen?  Messages can be interpreted.

## Graphic polymorphism

While dispatch on arbitrary composite values is powerful, it is by itself too
situated to serve as the basis of traits that exhibit contextual awareness.




## Macro expansion

Indeed, there are few good reasons to favor one group of things over another
based on a description of their characteristics.

## Representation

The realm of values non-propositional world.

Once a thing is being represented, we enter the Pure Data world, the realm of
ideals.

Is the pure-data world hard-partitioned from the resource world?

No, it extends the pure data world.

But the pure data world can name resources.  And those names can be treated
specially when considering premises.  Including the distinction between, say, a
named node and a variable.




## The value realm

Claims are also values, and may contain values.

Navigability between value and resources is achieved through the unifying
lens of a of datafy-nav cycle.

What are the tells of a value?

- They have no default interpretation as predicates.


## Navigation context - navigation

Terms can identify anything.

If the user navigates to a term, we look from that term's point of view.  And
what should we see? Representatives.

We should represent the world as from its point of view.  When we're in
agreement, we can knock out our contradictions.

Within structures where this thing is represented, this term, this triple,
remains in the navigation context.

Likewise, as long as we remain on a path through that resource, it remains in
our context.

## Navigation as creation

With the open-world assumption, you can't talk about non-existence.

Navigation creates a subject from what was an object.

We can write links to things that don't exist, users may follow them.

We can talk about things that don't exist, or don't exist yet, as far as anyone
around here knows.

To the extent that those links describe a thing, we can create it if it fails to
match the name of a thing we know.

We represent the thing in data form, only what we've heard.

## Shadow profiles

We can build our own "shadow profiles" of things.

Indeed, we do it all the time.  Our mermories are shadow profiles---mental
representations of a thing.


A shadow profile can be created with context, because there may be statements
*about* X already.  Even if you assume all subjects in a graph are given a home
(in the document), there's nothing stopping you from linking to such anchors.
In doing so, you can make a simple hashtag link a creative tool, since you can
capture in that link a lot of context.  Patterns seen in that context serve as
the basis of "graphical" polymorphism.  The tools to implement this are
available and simple.  The challenge is devising a language that can exploit it.
I argue that RDF must be the substrate of any such language with any hope of
survival.

To truly build shadow profiles, we'll need RDF 1.1 Datasets.  Claims that
*directly* originate from the domain in question, should be visually distinct
from claims from other domains.

These traits can be defined in terms of provenance.

Well, the fact that it has any.

## Domain to datafy: DOM Document Outline

View the DOM either "as dom" or "as document," the document outline is also
governed by some rules, which boil down basically to a set of element types,
which work mostly as a subselection.  Though there may be some rearrangement in
there.  Order of presentation is relaxed for side matter (aside, figure).

Content that already exists there,

## Domain to reify: DOM Events


## Domain to reify: simulation frames






## Bootstrapping - discovery - claims - interpreters
  
What do you need to bootstrap the system?
  
Claims.

- The system won't do anything without claims.
- The system is just a claim interpreter.
- It's actor model.  Some actors are interpreters.
  
- Q: How do the actors get there in the first place, though?
- A: By way of a description, which was given to an actor driver.

- Q: And how did the actor driver get there in the first place?
- A: By way of a driver loader.

- Q: And where did the driver loader come from?
- A: The driver loader is the system.  QED

### Another line of questioning

- Q: And who gave the actor driver the description?
- A: The claim store.

- Q: And where did this claim come from?
- A: You would have to check its provenance.

- Q: And what if it has no provenance?
- A: Then it is asserted by the model.

- Q: And how did the model come into possession of the claim?
- A: The host fed the claim to the system.

- Q: And where did the host get the claim?
- A: A graph was loaded during bootstrap.

- Q: And where did the model come from?
- A: Whatever discovery determined.

- Q: And how did discovery know where to look?
- A: Yes, that is the question now

- Q: What was discovery looking for?
- A: Ingresses.

## Initiative

- Q: Why was discovery looking for something?
- A: Discovery's job is to locate resources to engage with, assuming they may
  have something to say.

We begin in a nullary position with respect to action.

We deploy interpreters to incoming signals.

The interpreters may spur us to action.

## Process vocabulary

We can't do anything without processes.

Yet we have no shared, formal vocabulary for describing processes.

I don't want MELD to have a “built-in” process model.

Yet I'm not opposed to a *de facto* (core?) abstraction and implementation.  I
guess if it's recognized in core then it's “built-in”.

What are the main existing process/coordination models?
- CSP (blocking queue mechanism)
- Actor (extend CSP to include consideration of message semantics??
  Interceptors/event bus)
- PetriNet (token-state transition model)
- pi Calculus (?? model)
- Linda tuplespaces
- BIP ontology surveys some of these and others

For a simple vocabulary that can describe useful processes (not dataflows,
but as simple as `listensTo`), what terms would we need?

We would need something like `respondsTo`.  But the range would not be about
identifying the sender, it would be about describing the type of message to
match and how to formulate the response.

What can happen in the formulation of the response?  Nothing, the response must
be a pure function.  It can at most return a description of something that
should happen.

Can we consider HDOM templates basically a macro-language for defining
side-effects?  Or is it just a message type (hiccup/hdom)?  HDOM does
specifically support interpretation of JSON-based Expressions.

## Polymorphism - QUESTION about interpretation “as”

About the “as” part of interpret expressions...  Is it atomic?  Is it part of an
options map?  Can you specify/request interpretations it in a way that allows
matching on broader context (not “as X”).

Describe these contexts for me, and I'll answer that.

## Interpretation as content-type negotiation - example - frame simulations

We can interpret frame simulations as sequences, but a frame simulation is not a
process.  It requires a process, to be iterated.  That is, we can interpret a
frame simulation as a process *indirectly*, because of a polymorphism that
resembles a content-type negotiation: we can accept a Process, and the server
has an iterable and a thing for Processifying iterables.

## Processifiable

Revisiting this protocol in light of “everything is interpret-as”, or even more
broadly.

## Channels are Processifiable

We say that a thing can be “interpreted as a Process” if some registered
mechanism matches its description.

We already have this for (pseudo-)RDF resources, by way of driver rules.

So `DriverRule subclassOf Interpreter`?

They must be considered Processes, because they are enqueued invocation targets.



## Context access

The intent is that protocols (in a blessed or otherwise default namespace) can
be referenced by presumption of a term in a callback context.

```
({show, Keys}, subject) => [show, Keys(subject)]
```

We are interpreting the term as a protocol.

Undefined terms are largely ignored.

Determine whether the target implements the protocol.

If not, do nothing.

If so, dereference the protocol from the global registry using the
now-available local name.



## Render is still a synchronous, terminating function

In contained contexts, for example, we may show a lower-fidelity view of a
resource than we ourselves enjoyed.  The “charter” afforded here by the caller
to its child is expected to be a diminishing resource, or else the descent would
never terminate.

## Bottom-out operation

We need to bottom out on an element, and yes, there may be conflicts.

Multiple assertions of the same value do not conflict.

Handling of unequal values is necessarily domain-specific.

For HTML, we could classify elements as being more or less specific.  (**making
stuff up**).  A simple rubric would resolve most cases (e.g. `div` and `span`
are 0 points, everything else is 1 and up).  (For svg, `g` is the zero-point
container.)

## Viewpoints

- subject viewpoint :: subject + predicateList/JSON-LD object/Describe/Dispatch
- community viewpoint :: N-Triples/JSON-LD @graph/Construct/Announce

## We are processing claims. All day.

Basics:

We identify something called *models*.

A Model is syntactically expressed as an RDF triple store.

A Model is a community of claims, made in unison.

New claims enter the community generally unbidden.

But we accept them all as true.

## *De facto* protocols

- Keys
- Values
- Entries

Mostly implemented already, but not QUITE uniformly.


## Discoverability of protocol implementations

- Are protocols reified?
- Are implementations?
- If not, how are they discovered?
- We must determine how each item best fulfills each protocol
