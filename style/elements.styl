@import types

// MESO-GENERAL

// Identified
[id]:not([id=""])
  --prefix '#' attr(id)
  Tag()
  &::before
    font-size 200%
    background white
		
  // I would ALSO LIKE TO ASSERT that this thing has a link pointing back to
  // itself.
	
	// And I would like to say about the link that points back to itself, that it
	// should bear a label of the thing
	
	// And would like to say that `open`
	//  details shall drill a little further.
	//
	// Now, about that open state.  You know what happens when the thing is no
	// longer open?
	//
	// How much of this system could you drag-and-drop?  I mean, could you
	// bootstrap a whole thing through drag and drop?  Can that script execute in
	// your page, as if it were your own script?
	//
	// I would donate to a rule that carried out the further-drilling-down of
	// things matching within the context of an open details container.
	// 
	// This is navigation by expansion.  And it's monotonic.
	// 
	// But isn't it dataflow driven?
	//
	// No!  The stream input is really just a propellor.  This trampolining could
	// be done synchronously.  In which case you would have to query the rules so.
	// As it is, it's easier to subscribe to them as a stream.  Likewise, you have
	// reason to believe the dom will have changed, if the dataflow creates some
	// elements itself.  So then you re-run the XPath queries.
	//
	// A trampolining between datalog- and tree-traversal-style query languages.
	//
	// The fact that you have a long-lived process, though... will for the hdom
	// you won't.  Basically when a dom assertion fires, just apply the
	// operations.  Minting dom nodes is not “free,” but the cost is not like
	// computational cost, and anyway some minting is necessary to drive the
	// process, so it should not dry up too quickly.
	//
	// You don't need a long-lived process for the render.  Is that getting
	// through?  The satisfaction of assertions is discounted.
	//
	// Still, what happens?
	//
	// The matching elements are noticed, and the assertion is made.  Now, what do
	// you do when the assertion is true?  That's what I meant earlier... you want
	// to be able to assert the condition.  Else you have to make a template that
	// just repeats the pattern.  But in essence, you describe a pattern with some
	// placeholders.
	//
	// Crazy idea.  Does xpath eval in fact take an object as context?  Or give
	// you a callback for resolving variables?  If not the latter, you could use
	// getters or proxy to tell which variables were evaluated.
	//
	// Yet, we have to express the thing that we want to exist as a template.  But
	// we first need to assert whether an equivalent thing exists already.  And
	// how do we test equivalency, accounting for placeholders?
	// 
	// That's supposing that we treating this as a “there exists”.  But we will
	// not be able to prevent the redundant evaluation of the query expressions.
	// So you will need a fast and reliable way to test whether or not the
	// assertion made by this rule has already been applied to this element.
	// That's some bookkeeping.  The SPARQL side does this as `?thing implements
	// ?subject as ?type`
	//
	// This duet, by the way, is browser-only, and that's fine.
	//
	// The things we add are not going to go away.  We're just going to grow them,
	// or tuck them away.
	//
	// If you're three levels deep, you should be three levels deep.
	
	
	// This serves as an assertion, and we can make these for "free".
	// Well I mean there must be some cost to minting them.

// Classified
[class]:not([class=""])
  --type attr(class)

&:hover
  Indicated()
	
// ==================================== ELEMENTS: singletons

// How can you tell it's space?
Space()
  background-color var(--space-background)

html
  background none

body
.Space
  Space()

main
  // --main-background white
  margin var(--main-margin)

// ================================ ELEMENTS: SPECIAL

p
  Paragraph()

// Links are the holiest thing.
a
  Navigable()

ul
  UnorderedList()

ol
  OrderedList()

// How can you tell it's a label?
// label, .Label
//   background-color hsla(255 * var(--label-hue), 255 * var(--label-saturation), 255 * var(--label-luminosity), var(--label-alpha))

// STATEFUL : might be in collapsed state
details
  border 1em solid rgba(red, 0.1)

// AFFORDANCE
// STATEFUL : might be in collapsed state
summary
  Affordance()

aside
  border 1em solid yellow
  float right
  // width 50%

// unit of portability
// unit of context
// unit of provenance
//
// It may be all those things, but does it afford moving?
// Does it afford etc?
article
  display inline-block
  --article-margin 4em
  // border 2em solid rgba(black, 0.2)
  margin var(--article-margin)
  background rgba(black, 0.1)
  margin 1em

section
  margin-top 1em

header
  --type 'Header'

li
  --type 'Item'

// unit of provenance
// should have a citation nearby 
blockquote
  Lens() // not exactly, but out-of-context
  Quotation()
  margin-left 4em
  --alpha 0.6

cite
  Citation()

// ============================ POST rules
