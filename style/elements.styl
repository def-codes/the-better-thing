// Stylus <3 CSS variables.  Kind of.

// ========================= MIXINS

Thing()
  --type 'Thing'
  background-color s('hsla(var(--hue), var(--saturation), var(--luminosity), var(--alpha))')
  &::before
    content var(--prefix)

Indicator()
  font-size 100%
  // This will never show because below
  --type 'Indicator'

Indicated()
  --luminosity 50%

Affordance()
  Indicator()
  --type 'Affordance'
  cursor hand
  border 1em solid rgba(green, 0.2)
  box-shadow 0 0 2em -0.5em
  // Was curious... no such thing in Gecko.
  // &:active
  //   background #F00

  &:hover
    background var(--indicator-color)

Tag()
  Indicator()

Navigable()
  cursor pointer
  Affordance()
  --type 'Navigable'
	
Section()
  --type 'Section'
	
Header()
  --type 'Header'

Quotation
  --type 'Quotation'

Citation()
  --type 'Citation'

Draggable()
  header
    Affordance()
  // indicate draggability how

Lens()
  --type 'Lens'
  // something

Porthole()
  Lens()
  Navigable()
  --type 'Porthole'
  box-shadow inset 0 0 2em -0.5em
  width 20rem
  height 20rem
  border-radius 50%
  overflow hidden
  background #AAA

Paragraph()
  --type '¶'

Aside()
  --type 'Aside'

Collection()
  --type 'Collection'

List
  Collection()
  Sequence()
  // Type won't be seen because requires subtype.  But still
  --type 'List'

OrderedList()
  List()
  --type 'OrderedList'

Vector()
  OrderedList
  --type 'Vector'

UnorderedList()
  Collection()
  --type 'UnorderedList'
  border-bottom 1em solid orange

// =====================  ELEMENTS: GENERAL

// Global defaults
*
  Thing()
  transition 0.3s
  --space-background #222
  
  // --main-background rgba(white)

  padding 1em
  //background-color rgba(white, 0.01)
  border 1px solid rgba(black, 0.5)

  --prefix var(--type)

  --hue 0deg
  --saturation 100%
  --luminosity 100%
  --alpha 20%

  --label-hue 0deg
  --label-saturation 100%
  --label-lumunosity 100%
  // --label-alpha 1
  --indicator-color #FAA
  
  --border-hue 0deg
  --border-saturation 100%
  --border-luminosity 100%
  --border-alpha 1
  --border-color s('hsla(var(--border-hue), var(--border-saturation), var(--border-luminosity), var(--border-alpha))')

// MESO-GENERAL

[id]:not([id=""])
  --type '#' attr(id)
  Tag()
  &::before
    font-size 200%
		
  // I would ALSO LIKE TO ASSERT that this thing has a link pointing back to
  // itself.
	
	// And I would like to say about the link that points back to itself, that it
	// should bear a label of the thing
	
	// And would like to say that `open`
	//  details shall drill a little further.
	//
	// Now, about that open state.  You know what happens when the thing is no
	// longer open?
	//
	// How much of this system could you drag-and-drop?  I mean, could you
	// bootstrap a whole thing through drag and drop?  Can that script execute in
	// your page, as if it were your own script?
	//
	// I would donate to a rule that carried out the further-drilling-down of
	// things matching within the context of an open details container.
	// 
	// This is navigation by expansion.  And it's monotonic.
	// 
	// But isn't it dataflow driven?
	//
	// No!  The stream input is really just a propellor.  This trampolining could
	// be done synchronously.  In which case you would have to query the rules so.
	// As it is, it's easier to subscribe to them as a stream.  Likewise, you have
	// reason to believe the dom will have changed, if the dataflow creates some
	// elements itself.  So then you re-run the XPath queries.
	//
	// A trampolining between datalog- and tree-traversal-style query languages.
	//
	// The fact that you have a long-lived process, though... will for the hdom
	// you won't.  Basically when a dom assertion fires, just apply the
	// operations.  Minting dom nodes is not “free,” but the cost is not like
	// computational cost, and anyway some minting is necessary to drive the
	// process, so it should not dry up too quickly.
	//
	// You don't need a long-lived process for the render.  Is that getting
	// through?  The satisfaction of assertions is discounted.
	//
	// Still, what happens?
	//
	// The matching elements are noticed, and the assertion is made.  Now, what do
	// you do when the assertion is true?  That's what I meant earlier... you want
	// to be able to assert the condition.  Else you have to make a template that
	// just repeats the pattern.  But in essence, you describe a pattern with some
	// placeholders.
	//
	// Crazy idea.  Does xpath eval in fact take an object as context?  Or give
	// you a callback for resolving variables?  If not the latter, you could use
	// getters or proxy to tell which variables were evaluated.
	//
	// Yet, we have to express the thing that we want to exist as a template.  But
	// we first need to assert whether an equivalent thing exists already.  And
	// how do we test equivalency, accounting for placeholders?
	// 
	// That's supposing that we treating this as a “there exists”.  But we will
	// not be able to prevent the redundant evaluation of the query expressions.
	// So you will need a fast and reliable way to test whether or not the
	// assertion made by this rule has already been applied to this element.
	// That's some bookkeeping.  The SPARQL side does this as `?thing implements
	// ?subject as ?type`
	//
	// This duet, by the way, is browser-only, and that's fine.
	//
	// The things we add are not going to go away.  We're just going to grow them,
	// or tuck them away.
	//
	// If you're three levels deep, you should be three levels deep.
	
	
	// This serves as an assertion, and we can make these for "free".
	// Well I mean there must be some cost to minting them.

[class]:not([class=""])
  --type attr(class)

&:hover
  Indicated()
	
// ==================================== ELEMENTS: singletons

// How can you tell it's space?
Space()
  background-color var(--space-background)

html
  background none

body
.Space
  Space()

main
  // --main-background white
  margin var(--main-margin)

// ================================ ELEMENTS: SPECIAL

p
  Paragraph()

// Links are the holiest thing.
a
  Navigable()

ul
  UnorderedList()

ol
  OrderedList()

// How can you tell it's a label?
// label, .Label
//   background-color hsla(255 * var(--label-hue), 255 * var(--label-saturation), 255 * var(--label-luminosity), var(--label-alpha))

// STATEFUL : might be in collapsed state
details
  border 1em solid rgba(red, 0.1)

// AFFORDANCE
// STATEFUL : might be in collapsed state
summary
  Affordance()

aside
  border 1em solid yellow
  float right
  // width 50%

// unit of portability
// unit of context
// unit of provenance
//
// It may be all those things, but does it afford moving?
// Does it afford etc?
article
  display inline-block
  --article-margin 4em
  // border 2em solid rgba(black, 0.2)
  margin var(--article-margin)
  background rgba(black, 0.1)
  margin 1em

section
  margin-top 1em

// unit of provenance
// should have a citation nearby 
blockquote
  Quotation()
  margin-left 4em

cite
  Citation()
	
.Porthole
  Porthole()
  text-align center

// ============================ POST rules
