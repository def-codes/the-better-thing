<!DOCTYPE html>
<html lang="en">
  <head>
    <title>the better thing</title>
    <meta charset="utf-8" />
    <link href="index.css" rel="stylesheet" />
  </head>
  <body>
    <main>
      <header>
        <h1>the better thing</h1>
        <ul>
          <li><a href="model.html?host">host</a></li>
          <li><a href="model.html?streams">streams</a></li>
          <li><a href="model.html?stream-merge">stream merge</a></li>
          <li><a href="model.html?ticker">ticker</a></li>
          <li><a href="model.html?subscription">subscription</a></li>
          <li><a href="model.html?transducers">transducers</a></li>
          <li><a href="model.html?mapping-transducers">mapping transducers</a></li>
          <li><a href="model.html?filtering-transducers">filtering transducers</a></li>
          <li><a href="model.html?partitioning-transducers">partitioning transducers</a></li>
          <li><a href="model.html?traversal">traversal</a></li>
          <li><a href="model.html?projection">projection</a></li>
          <li><a href="model.html?containers">containers</a></li>
          <li><a href="model.html?selection">selection</a></li>
          <li><a href="model.html?representation">representation</a></li>
          <li><a href="model.html?facts">facts</a></li>
          <li><a href="model.html?blank-nodes">blank nodes</a></li>
          <li><a href="model.html?queries">queries</a></li>
          <li><a href="model.html?rules">rules</a></li>
          <li><a href="model.html?macros">macros</a></li>
          <li><a href="model.html?layers">layers</a></li>
          <li><a href="model.html?symmetrical">symmetrical properties</a></li>
          <li><a href="model.html?transitive">transitive properties</a></li>
          <li><a href="model.html?classes">classes</a></li>
          <li><a href="model.html?subclasses">subclasses</a></li>
          <li><a href="model.html?forcefield">forcefield</a></li>
        </ul>
      </header>
      <section id="examples">
      </section>
      <section>
        <h2><i>not</i> covered today</h2>
        <section>
          <h3>non-monotonicity</h3>
          <p>a difficult problem</p>
          <p>examples recreate the world</p>
          <p>time is monotonic.  if it weren't...</p>
        </section>
        <section>
          <h3>direct manipulation</h3>
          <p>because non-monotonicity</p>
        </section>
        <section>
          <h3>negation</h3>
          <p>like non-monotonicity, logical negation dramatically complicates
          the system.</p>
          <p>focus first on what you <i>can</i> do</p>
        </section>
        <section>
          <h3>other caveats</h3>
          <p>the particulars are secondary</p>
          <p>this is about a set of ideas</p>
          <p>deep dives later in the year</p>
        </section>
      </section>
      <section>
        <h2>the big ideas</h2>
        <section>
          <h3>bicycles for the mind</h3>
          <p>computers as “fantasy amplifiers” (Alan Kay) or “bicycles for the
          mind” (Steve Jobs?)</p>
        </section>
        <section>
          <h3>description</h3>
        </section>
        <section>
          <h3>information</h3>
          semantics, meaning, knowledge
          AK: the system knows something about itself and what it's doing
        </section>
        <section>
          <h3>visibility</h3>
        </section>
        <section>
          <h3>provenance</h3>
        </section>
        <section>
          <h3>monotonic growth</h3>
        </section>
        <section>
          <h3>play</h3>
          http://nautil.us/issue/73/play/why-it-pays-to-play-around
          https://news.ycombinator.com/item?id=20131672
        </section>
        <section>
          <h3>close-enough answers</h3>
          approximate answers are good enough in many cases
        </section>
        <section>
          <h3>visibility-by-default</h3>
          death to console.log
          <blockquote>
            <p>
              Another example. Most programs today manipulate abstract data
              structures and opaque objects, not pictures. How can we visualize
              the state of these programs?
            </p>
            <p>
              Again, wrong question. A better attitude is to assert that we have
              to be able to understand the state of our programs. We can then
              ask: <i>How do we design data structures that can be
              visualized?</i> Can we invent data structures that are
              <i>intended</i> to be visualized? <mark>How do we move towards a
              culture where only visually-understandable data is considered
              sound?</mark> Where opaque data is regarded in the same way that
              "goto" is today?
            </p>
            <p>
              Bret Victor, <a href="http://worrydream.com/LearnableProgramming/#end">
                “Learnable Programming”
              </a>
            </p>
          </blockquote>
          <p>how do you know if the problem is with the thing you're interested
          in, or with your means of seeing it.</p>
        </section>
        <section>
          <h3>open world assumption</h3>
          <p>design, including system design, information design, interaction
          design, and even graphic design, proceeds by making claims</p>
          <p>ontologies can find contradictions in claims (and also help us say
          more with less)</p>
          <p>contrast this with the closed-world thinking that dominates</p>
        </section>
        <section>
          <h3>dynamic thinking <i>versus</i> static thinking</h3>
          userspace versus kernelspace
          spec versus type systems.  TypeScript is dead.  Long live TypeScript!
        </section>
        <section>
          <h3>heterogeneity</h3>
          <p>a.k.a. “diversity”. make form secondary in order to intermix
          domains</p>
        </section>
        <section>
          <h3>green and yellow code</h3>
          <p>from raganwald, IIRC</p>
          <p>green code is userland code</p>
          <p>yellow code is kernel code (system and drivers)</p>
        </section>
      </section>
      <section>
        <h2>ideas here</h2>
        <section>
          <h3>space is the place</h3>
          <p>screens are cages, we won't miss them</p>
          <p>we need to think about computing in space <i>now</i></p>
        </section>
        <section>
          <h3>forcefield as default layout</h3>
          <p>we put things into space</p>
        </section>
        <section>
          <h3>userland homoiconicity</h3>
          <p>work at once on model and its representation</p>
        </section>
        <section>
          <h3>rdf as bytecode</h3>
          <p>See this for example.
          https://m00natic.github.io/lisp/manual-jit.html
          https://news.ycombinator.com/item?id=20191406
          looks interesting (on my reading list), but still no mention of RDF
          </p>
        </section>
        <section>
          <h3>death to console log</h3>
          <p>visible, dynamic... but deserves mention</p>
          <p>actually... we can intercept console log and do a “good thing” with
          it.  someone has to work on drivers and interop, after all, so why not
          make things less painful?</p>
        </section>
        <section>
          <h3>multi-dialect</h3>
          <p>turtle, lisp, and javascript</p>
          <p>macros</p>
        </section>
        <section>
          <h3>“forgotten” ideas</h3>
          <p>as per Armstrong --- or Sussman.  We've moved on to wildly complex
          things but never really mastered the older things (reasoners, expert
          systems) </p>
        </section>
        <section>
          <h3>cut the machine loose</h3>
          <p>RDF as compilation source and target</p>
          <p>there is no reason to use lower-level languages</p>
        </section>
      </section>
      <section>
        <h2>future</h2>
        <section>
          <h3>reintroduce namespaces</h3>
          <ul>
            <li>can still write "bare" terms by defaulting certain imports</li>
            <li>or you can use prefix approach (CURIE's) </li>
          </ul>
        </section>
      </section>
      <section>
        <h2>examples</h2>
        <section>
          <h3>playing with file system</h3>
          <p>force-directed layout for files</p>
          <p>cluster by some quality</p>
          <p>display with relative size --- or any other metric you can compute</p> 
        </section>
        <section>
          <h3>boggle example outline</h3>
          <pre>
            - the board
            - the board is just a graph
            - the word list
            - the word list is used to construct a trie
            - the trie
            - a trie is a special kind of tree
            - a prefix tree
            - prefix matches (or non matches)
            - the search
            - stateful
            - the rules
            - rules are used to prune the search space
            - the display
            - the solutions
          </pre>
        </section>
      </section>
    </main>
  </body>
</html>
